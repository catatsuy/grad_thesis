The hardware description in ArchHDL is similar to that of Verilog HDL.
The hardware RTL modeling on ArchHDL is done with
\textit{Module} class, \textit{reg} class, \textit{wire} class
and the lambda function of C++11.

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/counter8.cc}
 \caption{A description of 8-bit counter in ArchHDL.}
 \label{src:counter}
\end{figure}

\begin{figure}[t]
 \lstinputlisting[language=verilog]{src/counter8.v}
 \caption{A description of 8-bit counter in Verilog HDL.}
 \label{src:counter_v}
\end{figure}

\figref{src:counter_v} shows a code of 8-bit counter in Verilog HDL.
The code for the same 8-bit counter in ArchHDL is shown
in \figref{src:counter}.
In the code in ArchHDL,
a class which declared as a subclass of the \textit{Module} class
corresponds to a module of Verilog HDL.
In the following, we call this class ``\textit{Module child} class''.
Similarly, the \textit{reg} class and the \textit{wire} class
correspond to a register and a wire of Verilog HDL respectively.

In a \textit{Module child} class, A \textit{Init} function and An \textit{Always} function are declared for a wire assignment and a register assignment.

In the \textit{Init} function, users write the assignment of all wire in a module.
To realize the continuous assignment in C++, ArchHDL uses the lambda function and defines all wire as a function.
The description in \textit{Init} function corresponds to the assign statement of Verilog HDL.
In the line 6 of \figref{src:counter}, the lambda function (\texttt{[=]() \{ return counter(); \}}) which returns a value of \textit{reg counter} is assigned to the \textit{wire out}.
Note that, the value of the \textit{reg} class object can be get by calling the object as a function.
Therefore, the function call \textit{counter()} returns the value of \textit{reg counter}.
This statement equals to the line 6 of \figref{src:counter_v}.

In the \textit{Always} function, users write the assignment of all register in a module.
In ArchHDL, the assignment of a value to a register is allowed only at the time of a positive edge of a single clock.
ArchHDL realizes the non-blocking assignment to a register using \verb`<<=` operator.
In the ArchHDL library, the \verb`<<=` operator is overloaded as the non-blocking assignment implementation.
Therefore, statements in the \textit{Always} function is corresponds to statements in the \texttt{always@(posedge clock)} block in Verilog HDL.
In the line 9 of \figref{src:counter}, the \textit{reg counter} is assigned an incremented value of itself.
This statement equals to the line 8 of \figref{src:counter_v}.

ArchHDL uses the integer type of C++ as a data type of registers and wires.
In the example shown in \figref{src:counter}, we used \textit{unsigned int} as the data type for the register and the wire.
To implement the 8-bit counter in ArchHDL, the value of \textit{unsigned int} is masked by \texttt{0xff} as in the line 9 of \figref{src:counter}.


\section{Test bench description of ArchHDL}

ArchHDL is implemented using C++.
Users are able to describe a test bench flexibly to the extent possible in C++.
In this section, we show an example of a test bench in ArchHDL which is similar to a test bench in Verilog HDL.

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/cnt_testtop.cc}
 \caption{A sample description of a test bench for the 8-bit counter in ArchHDL}
 \label{src:test}
\end{figure}

\figref{src:test} is an example of a test bench for the 8-bit counter shown in \figref{src:counter} using ArchHDL.
The description of includes and definitions are omitted.
The variable \textit{HALT\_CYCLE} used in the line 14 and 16 is a constant number.

This test bench is designed as making the test module \textit{TestTop} to test the 8-bit counter in it.
In this way, the description of the \textit{main} function (in the line 22 to 28) becomes simple.
Only the creation of the \textit{TestTop} module instance and the call of \textit{Step} function are written in the main function.

The \textit{reg} class instances and the \textit{wire} class instances in a \textit{Module child} class are managed in the ArchHDL library.
The pointers of them are passed to ArchHDL library when the instance of the \textit{Module child} class is created.
Thus, the simulation of the 8-bit counter can be carried out only with the call of \textit{Step} function which defined in the ArchHDL library after the creation of \textit{TestTop} module.

\begin{figure}[t]
 \lstinputlisting[language=verilog]{src/cnt_testtop.v}
 \caption{A sample description of a test bench for the 8-bit counter in Verilog HDL}
 \label{src:test_v}
\end{figure}

\figref{src:test_v} is an example of a test bench for the 8-bit counter in Verilog HDL.
ArchHDL is able to write a test bench in similar description in Verilog HDL.
The major difference between the test bench in ArchHDL and Verilog HDL is the description of clock generation which is denoted in the line 14 of \figref{src:test_v}.
Otherwise there is no significant difference in the description in ArchHDL and Verilog HDL.

\section{Implementation of ArchHDL} \label{ss:implementation}

Seven classes are defined in the ArchHDL library.
They are \textit{Module} class, \textit{ModuleInterface} class, \textit{wire} class, \textit{WireInterface} class, \textit{RegInterface} class, \textit{reg} class and \textit{Singleton} class.
In this section, we explain about the implementation of ArchHDL library while showing its source code.

\begin{figure}[p]
 \lstinputlisting[language=c++,basicstyle=\ttfamily\footnotesize]{src/singleton.cc}
 \caption{The source code of each interface class, \textit{Singleton} class and \textit{Step} function in the ArchHDL library.}
 \label{src:class_singleton}
\end{figure}

\figref{src:class_singleton} shows the definition of \textit{RegisterInterface} class, \textit{ModuleInterface} class, \textit{WireInterface} class, \textit{Singleton} class and Step function.

\textit{ModuleInterface} class, \textit{WireInterface} class and \textit{RegisterInterface} class are interface classes of \textit{Module} class, \textit{wire} class and \textit{reg} class respectively.
ArchHDL adopts the singleton pattern, and \textit{Singleton} class consolidate instances of \textit{Module child} class, \textit{wire} class and \textit{reg} class.
This class is the most important class in the ArchHDL library.

As member variables, \textit{Singleton} class has three dynamic arrays which keep pointers of \textit{Module} class, \textit{wire} class and \textit{reg} class (denoted in the line from 18 to 20).
When the instance of a \textit{Module child} class, a \textit{wire} class or a \textit{reg} class is created, the pointer to its class is passed to the instance of \textit{Singleton} class.
At that time, the pointer is upcasted to its interface class automatically (denoted in the line from 26 to 34).

The \textit{Step} function is the function to do one cycle simulation of implemented hardware.
In the \textit{Step} function, the \textit{Init} function and the \textit{Exec} function in \textit{Singleton} class are called.
The multicycle simulation can be carried by repeated call of the \textit{Step} function.

The \textit{Init} function of \textit{Singleton} class (denoted in the line from 35 to 39) calls the \textit{Init} function of all \textit{Module child} class instance which kept in \textit{Singleton} class.
Note that, the \textit{Init} function in \textit{Singleton} class is only called at the first call of the \textit{Step} function.

In the \textit{Exec} function (denoted in the line from 40 to 47), at first \textit{Always} functions of All \textit{Module chile} class instance held in \textit{Singleton} class are called (denoted in the line 42).
Next, \textit{Update} functions of All \textit{reg} class instance held in \textit{Singleton} class are called (denoted in the line 45).

A value at next cycle of all register is computed by calling the \textit{Always} function.
The value of registers are updated to the new value by calling the \textit{Update} function.
The process of the \textit{Always} function and the \textit{Update} function implements the non-blocking assignment of Verilog HDL.

\subsection{Definition of reg class}

\begin{figure}[tp]
 \lstinputlisting[language=c++]{src/reg.cc}
 \caption{The source code of \textit{reg} class in the ArchHDL library.}
 \label{src:reg}
\end{figure}

\figref{src:reg} shows the definition of \textit{reg} class.
This class is a template class which takes a data type to use in the class as the template argument.
The \textit{RegisterInterface} class is inherited as the interface class.

ArchHDL deals a register as a variable.
Therefore, the \textit{reg} class has two variables \textit{curr\_} and \textit{next\_} which data type is given by the template arguments.
The value of \textit{curr\_} is a value at one cycle, and the value of \textit{next\_} is a value at the next cycle.
A value is assigned to the variable \textit{next\_} by calling the \textit{Always} function.
The value of the variable \textit{next\_} is assigned to the variable \textit{curr\_} by calling the \textit{Update} function which is a member method of \textit{reg} class.
In this way, the non-blocking assignment to the register is carried out.

To assign a value to the variable \textit{next\_} in the \textit{reg} class object, \verb`<<=` operator is used.
We redefine the \verb`<<=` operator using operator overload.
The value assigned to the \textit{reg} class object by the \verb`<<=` operator is stored to the variable \textit{next\_}.
At the same time of assignment, the \textit{set\_} flag is set.

After calling the \textit{Always} functions of all \textit{Module} class instance, the \textit{Update} functions of all \textit{reg} class instance are called.
Thus, the value of the variable \textit{curr\_} in \textit{reg} class is kept while the function call of the \textit{Always} functions.

The constructor of \textit{reg} class initializes the member variables and give the pointer of itself to \textit{Singleton} class.
The assignment to \textit{reg} class object by \verb`=` operator is also defined for the description of test bench or the setting of initial value.
The value assigned to the \textit{reg} class object by the \verb`=` operator updates the variable \textit{next\_} immediately.
The value of \textit{reg} class is given by calling the object as a function.

\subsection{Definition of wire class}

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/wire.cc}
 \caption{The source code of \textit{wire} class in the ArchHDL library.}
 \label{src:wire}
\end{figure}

\figref{src:wire} shows the definition of \textit{wire} class.
This class is a template class which takes a data type to use in the class as the template argument.
The \textit{WireInterface} class is inherited as the interface class.

ArchHDL deals wire as a function.
Therefore, \textit{wire} class has a variable \textit{lambda\_} to hold a lambda function.
The data type of return value of this lambda function is the data type given by the template argument.

The assignment to the \textit{wire} class object is limited to the assignment of the lambda function by disallowing the copy constructor and overloading the = operator.
In this way, the \textit{wire} class becomes to be the class which held a lambda function described in the \textit{Init} function of \textit{Module child} class.

The constructor of \textit{wire} class initializes the member variables and give the pointer of itself to \textit{Singleton} class.
Calling the object of \textit{wire} class as a function, it returns the return value of lambda function evaluation.
Thus, a value of a wire at one cycle can be get from the function call of the \textit{wire} class object.

\subsection{Definition of Module class}

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/module.cc}
 \caption{The source code of \textit{Module} class in the ArchHDL library.}
 \label{src:module}
\end{figure}

\figref{src:module} is the definition of \textit{Module} class.
This class inherits \textit{ModuleInterface} class.
We use \textit{Module} class as the parent class to describe a module in ArchHDL.

The constructor of \textit{Module} class gives the pointer of itself to \textit{Singleton} class.
The \textit{Init} function and the \textit{Always} function are declared as virtual functions in \textit{Module\-Interface}.
Therefore, the empty \textit{Init} function and the empty \textit{Always} function are also defined in \textit{Module} class.
